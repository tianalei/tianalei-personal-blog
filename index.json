[{"content":"学校图书馆换了新的验证码预约系统，用户每天22:45准时完成滑块验证才能抢到次日座位，整个流程包括登录系统→选择区域→对准滑块缺口→卡点提交，任何一个环节延迟都可能前功尽弃，可谓手残党克星。当我第三次因为手抖把滑块滑偏，看着近10秒的验证耗时，意识到必须想办法自救。从灵光乍现到方案成型，整个过程只用了两杯咖啡的时间，以下是一点实战心得。\n🥳 最终实现效果 Before: 手动模式 \u0026#34;bookDate\u0026#34;: \u0026#34;2025-xx-xx 22:45:04\u0026#34;, \u0026#34;bookDate\u0026#34;: \u0026#34;2025-xx-xx 22:45:07\u0026#34;, \u0026#34;bookDate\u0026#34;: \u0026#34;2025-xx-xx 22:45:05\u0026#34; After: Tampermonkey 脚本 \u0026#34;bookDate\u0026#34;: \u0026#34;2025-xx-xx 22:45:00\u0026#34;, 目前方案虽不算完美（仍需15秒内完成手动验证），但实测将操作误差从±7秒压缩到毫秒级，已经能保证稳定抢到目标座位。就像给老式汽车加装定速巡航——虽不是全自动驾驶，但至少不用再脚踩油门与时间赛跑~\n1️⃣ 原始手动模式：与时间赛跑 滑动滑块到缺口位置，然后在22:45:00迅速松开。最简单直观的方法。但这个方法最大的敌人是薛定谔的验证时间：你以为4秒能搞定，实际可能花7秒。最崩溃的一次尝试：22:44:59松手，\u0026ldquo;未到预约开放时间\u0026rdquo;；22:45:00松手，\u0026ldquo;验证码被黑洞吸走了，请重试\u0026rdquo;。可能遇到的情况：22:45:03重试成功，心仪座位已被约。\n虽然实际因为运气好，暂时还没遇到没抢到座位的情况，但通常目标座位区域在15秒内就已经全部被抢光，所以这个方法的容错率很低。在“可能抢不到”的焦虑催生下，有了后续的方案。\n2️⃣ Proxyman 断点：延迟执行冻结请求 由于预约请求 /bookseat 是在验证码校验 /check 成功后立即POST，那么如果能控制/bookseat请求发送的精确时间，就能绕过不确定的人类操作延迟。选择Proxyman是因为它的 Breakpoint 功能可以冻结请求，就像给网络请求打了断点，可以手动延迟执行请求。\n设置：在 Proxyman Tools \u0026gt; Breakpoints 中设置断点规则\nMatching Rule (Request): https://xxxx.xxx.xxx.edu.cn/*/bookseat/* 预约步骤：\n确保其他 Proxy 工具已关闭（必须）。 打开已启用 SSL proxying 的浏览器（例如 Chrome），并选择座位。 点击“确认”按钮，调起滑块验证，并在 22:44:45 秒后通过验证，自动唤起Proxyman 断点窗口。 在 22:45:00 秒，在断点窗口 Excute Request。 这样，在 Proxyman 中设置 Breakpoint Rule 后，当请求匹配到指定的 URL时，会自动暂停请求并在断点窗口中显示。用户可以在断点窗口中手动延迟请求的执行时间，以便在指定的时间点（22:45:00 秒）执行 Request，完成抢座位的操作。\n实测发现关键点在于：\n系统的timeout设置约15秒，所以最多提前15秒完成滑块验证 本地时间应该要与服务器严格同步（这个误差目前可以忽略） Proxyman的Proxy和电脑其他Proxies不能兼容，setup起来比较麻烦 3️⃣ Proxyman 脚本：15秒容错窗口 但是，每次都盯着时钟点\u0026quot;Execute\u0026quot;请求还是有点麻烦。于是，我想到用 proxyman scripting 直接让程序自动处理。\n设置：在 Proxyman \u0026gt; Scripting 中设置下面的脚本 // # Name: 捕获并延迟到指定时间请求 // # URL (Request): https://xxxx.xxx.xxx.edu.cn/*/bookseat/* // 图书馆预约开放时间 const TARGET_HOUR = 22; // 小时（24小时制） const TARGET_MIN = 45; // 分钟 const TARGET_SEC = 00; // 秒 function onRequest(context, url, request) { // 计算目标时间 const now = new Date(); const targetTime = new Date( now.getFullYear(), now.getMonth(), now.getDate(), TARGET_HOUR, TARGET_MIN, TARGET_SEC ); // 计算延迟时间（毫秒） const delay = targetTime - now; // 时间窗口检查（0-15秒） if (delay \u0026gt;= 0 \u0026amp;\u0026amp; delay \u0026lt;= 15000) { console.log(`延迟请求: ${delay}ms`); sleep(delay); return request; } else { console.log(\u0026#34;放弃请求：超出时间窗口\u0026#34;); return request; } } 预约步骤：\n确保其他 Proxy 工具已关闭（必须）。 打开已启用 SSL proxying 的浏览器（例如 Chrome），并选择座位。 调起滑块验证，并在 22:44:45 秒后通过验证，自动唤起Proxyman 断点窗口。 这样，在 Proxyman 中设置 Script 后，当请求匹配到指定的 URL，脚本会延迟到22:45:00准时执行请求，从而提高抢座位的成功率。\n4️⃣✅ 完全基于浏览器方案：Tampermonkey脚本实现 那么，既然能直接拦截浏览器XHR请求，为什么不省去设置外部代理工具的环境，完全基于浏览器脚本实现？\n设置：安装 Tampermonkey 扩展后添加以下脚本 // ==UserScript== // @name 学校图书馆预约抢座(22:44:45~45:00完成滑块验证) // @namespace http://tampermonkey.net/ // @version 0.1 // @description 捕获并延迟POST请求到指定时间 // @author Tiana Lei // @match https://xxxx.xxx.xxx.edu.cn/* // @grant none // ==/UserScript== (function() { \u0026#39;use strict\u0026#39;; const TARGET_HOUR = 22; // 小时（24小时制） const TARGET_MIN = 45; // 分钟 const TARGET_SEC = 0; // 秒 var originalOpen = XMLHttpRequest.prototype.open; var originalSend = XMLHttpRequest.prototype.send; // 正则表达式，用于匹配URL const targetPattern = /^https:\\/\\/xxxx\\.xxx\\.xxx\\.edu\\.cn\\/.*bookseat\\/.*/; XMLHttpRequest.prototype.open = function(method, url) { if (method === \u0026#34;POST\u0026#34; \u0026amp;\u0026amp; targetPattern.test(url)) { var that = this; this.realSend = this.send; // 保存原始send方法 this.send = function(data) { // 获取当前时间和目标时间 const now = new Date(); const targetTime = new Date( now.getFullYear(), now.getMonth(), now.getDate(), TARGET_HOUR, TARGET_MIN, TARGET_SEC ); // 计算延迟时间（毫秒） const delay = targetTime - now; console.log(`当前时间：${now}, 目标时间：${targetTime}, 计算得到延迟：${delay}ms`); // 输出延迟时间 // 延迟发送请求 if (delay \u0026gt; 0 \u0026amp;\u0026amp; delay \u0026lt;= 15000) { // 如果在时间窗口内 console.log(`延迟发送：${delay}ms`); // 输出延迟信息 setTimeout(function() { console.log(\u0026#39;延迟请求被发送\u0026#39;); // 延迟后执行的日志 that.realSend(data); // 延迟发送原始请求 }, delay); } else { console.log(\u0026#39;超出时间窗口，直接发送请求\u0026#39;); // 如果超出时间窗口，直接发送请求 that.realSend(data); // 超出时间窗口，直接发送 } }; } else { console.log(`跳过，非目标POST请求，URL: ${url}`); // 如果不是目标请求，跳过 } originalOpen.apply(this, arguments); // 调用原始open方法 }; XMLHttpRequest.prototype.send = function(data) { originalSend.apply(this, arguments); // 调用原始send方法 }; })(); 现在的最佳操作流程变成：\n22:44:30 优雅地抿口咖啡 22:44:45~22:44:59 从容完成滑块验证（预留15秒容错） 浏览器脚本在00秒准时发送请求 至此，抢座焦虑已成过去式。Enjoy ~\n","permalink":"https://tianalei.github.io/personal-blog/posts/2025-02-19-whu-library-seat-reservation-scripting/","summary":"\u003cp\u003e学校图书馆换了新的验证码预约系统，用户每天22:45准时完成滑块验证才能抢到次日座位，整个流程包括\u003ccode\u003e登录系统→选择区域→对准滑块缺口→卡点提交\u003c/code\u003e，任何一个环节延迟都可能前功尽弃，可谓手残党克星。当我第三次因为手抖把滑块滑偏，看着近10秒的验证耗时，意识到必须想办法自救。从灵光乍现到方案成型，整个过程只用了两杯咖啡的时间，以下是一点实战心得。\u003c/p\u003e","title":"学校图书馆新系统滑块验证码抢座方法(2025)"},{"content":"记录 macOS/ubuntu 环境下常见开发工具问题的解决方案和 bug 修复\n⭕️ Proxyman Internal Error 999 Toggle off any other proxy app (CRUCIAL!) Configure Proxyman settings: Advanced Proxy Settings \u0026gt; External Proxy Settings \u0026gt; Enable Web Proxy (HTTP) \u0026gt; Set it to the system proxy address, e.g., 127.0.0.1:7890 ⭕️ VSCode Latex Workshop build error: \u0026ldquo;spawn latexmk ENOENT\u0026rdquo;, \u0026ldquo;LaTeX build process spawned with PID undefined\u0026rdquo; First, verify latexmk path is in the system PATH\n➜ ~ which latexmk /Library/TeX/texbin/latexmk ➜ ~ echo $PATH\t# Look for /Library/TeX/texbin in the output If it is but the error persists, try granting permissions to the texbin directory\nsudo chown -R \u0026lt;username\u0026gt; /Library/TeX/texbin If still not working, grant \u0026ldquo;Full Disk Access\u0026rdquo; to VSCode (this worked for me).\n⭕️ VSCode Latex Workshop build error: \u0026ldquo;Cannot find LaTeX root file\u0026rdquo; or \u0026ldquo;Active document is not a TeX file\u0026rdquo; Identify the problem: According to the error log, the language ID is django-txt, which is not a LaTeX file type.\n[01:21:25.491][Build] The document of the active editor: file://%WS1%/file.tex [01:21:25.491][Build] The languageId of the document: django-txt [01:21:25.491][Build] Cannot find LaTeX root file. See https://github.com/James-Yu/LaTeX-Workshop/wiki/Compile#the-root-file The Solution: 把 VS Code 右下角的语言模式切换为 LaTeX。Check the language mode in the bottom-right corner of VS Code. If it shows anything other than LaTeX (e.g., django-txt), change it to LaTeX.\nSelect language mode\n🛠️ Building QGIS from source for Apple Silicon (M1 Pro, macOS Sonoma 14.4) For a detailed guide for this, check out my reddit post below for the complete process.\nBuild and install QGIS with native Apple Silicon (M1 Pro, Sonoma 14.4)\nbyu/Ok-Sky-1162 inQGIS","permalink":"https://tianalei.github.io/personal-blog/posts/2025-02-18-my-troubleshooting-notes-solutions-and-bug-fixes/","summary":"\u003cp\u003e记录 macOS/ubuntu 环境下常见开发工具问题的解决方案和 bug 修复\u003c/p\u003e","title":"My Troubleshooting Notes: Solutions and Bug fixes"}]